<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Missile Command: Final</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            color: #f00; 
            font-family: 'Courier New', Courier, monospace; 
            touch-action: none; /* スクロール防止 */
            user-select: none; 
            -webkit-user-select: none; 
        }
        canvas { 
            display: block; 
            width: 100%;
            height: 100%;
        }
        
        /* UI Layer */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }
        .top-bar {
            display: flex; justify-content: center; padding: 15px; 
            font-weight: bold; font-size: 24px; color: #f00; letter-spacing: 2px;
            text-shadow: 0 0 5px #f00;
        }
        
        /* Screens */
        #overlay, #bonus-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 20;
            background: rgba(0, 0, 0, 0.85);
        }
        #bonus-screen { display: none; background: transparent; pointer-events: none; }
        .bonus-box {
            background: #000; border: 4px double #f00; padding: 30px; 
            width: 300px; text-align: center;
        }

        /* Typography */
        h1 { font-size: 40px; color: #f00; text-shadow: 2px 2px 0 #fff; margin: 0 0 20px 0; letter-spacing: 5px; text-align: center; line-height: 1.2;}
        p { color: #fff; font-size: 18px; margin: 5px; }
        .blink { animation: blinker 1s linear infinite; }
        @keyframes blinker { 50% { opacity: 0; } }
        
        button {
            background: #f00; color: #000; border: 2px solid #fff;
            padding: 15px 40px; font-size: 20px; margin-top: 30px;
            font-family: inherit; font-weight: bold; cursor: pointer;
            box-shadow: 0 0 15px #f00;
            border-radius: 4px;
        }
        button:active { background: #fff; color: #f00; transform: scale(0.95); }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="top-bar">
        <div id="scoreEl">SCORE: 0</div>
    </div>
</div>

<div id="bonus-screen">
    <div class="bonus-box">
        <h2 style="color: #fff; margin-top:0;">WAVE CLEARED</h2>
        <div style="display:flex; justify-content:space-between; color:#ff0; margin:5px 0;"><span>BONUS:</span><span id="bonus-val">0</span></div>
        <div style="display:flex; justify-content:space-between; color:#0f0; margin:5px 0;"><span>AMMO:</span><span id="ammo-bonus">0</span></div>
        <div style="display:flex; justify-content:space-between; color:#0ff; margin:5px 0;"><span>CITIES:</span><span id="city-bonus">0</span></div>
    </div>
</div>

<div id="overlay">
    <h1 id="title-text">MISSILE<br>COMMAND</h1>
    <p class="blink" id="status-text">DEFEND CITIES</p>
    <button id="start-btn">INSERT COIN</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- Audio System ---
    const AudioSys = {
        ctx: null,
        init: function() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
        },
        playTone: function(freq, type, duration, vol) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        playShoot: function() { this.playTone(800, 'square', 0.2, 0.1); },
        playExplosion: function() {
            if (!this.ctx) return;
            const dur = 0.5;
            const bufSize = this.ctx.sampleRate * dur;
            const buf = this.ctx.createBuffer(1, bufSize, this.ctx.sampleRate);
            const data = buf.getChannelData(0);
            for(let i=0; i<bufSize; i++) data[i] = Math.random() * 2 - 1;
            
            const src = this.ctx.createBufferSource();
            src.buffer = buf;
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
            src.connect(gain);
            gain.connect(this.ctx.destination);
            src.start();
        },
        playEmpty: function() { this.playTone(150, 'sawtooth', 0.1, 0.1); },
        playStart: function() { 
            // 起動音
            if (!this.ctx) return;
            const now = this.ctx.currentTime;
            [440, 554, 659].forEach((f, i) => {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = f;
                g.gain.value = 0.05;
                osc.connect(g);
                g.connect(this.ctx.destination);
                osc.start(now + i*0.1);
                osc.stop(now + i*0.1 + 0.1);
            });
        }
    };

    // --- Game Logic ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('scoreEl');
    const overlay = document.getElementById('overlay');
    const bonusScreen = document.getElementById('bonus-screen');
    const startBtn = document.getElementById('start-btn');
    const titleText = document.getElementById('title-text');
    const statusText = document.getElementById('status-text');

    let width, height; // Logical size
    let score = 0;
    let level = 1;
    let gameActive = false;
    let isPaused = false;
    let lastTime = 0; // For Delta Time
    let spawnTimer = 0;

    // Entities
    let cities = [];
    let silos = [];
    let missiles = []; // Both player and enemy
    let explosions = [];

    // Config
    const CONFIG = {
        cityCount: 6,
        siloCount: 3,
        baseAmmo: 10,
        colors: ['#000', '#100', '#001', '#010'],
        playerSpeed: 600, // px per second
        enemySpeedBase: 40, // px per second
        explosionRadius: 45
    };

    // Resize Handler with HiDPI support
    function resize() {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        
        // Canvasの物理サイズを設定
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        
        // コンテキストのスケールを合わせる
        ctx.scale(dpr, dpr);
        
        // オブジェクトの再配置（画面回転対応）
        repositionObjects();
    }

    function repositionObjects() {
        if (cities.length === 0) return; // 初期化前

        // 都市の再配置
        const citySpacing = width / (CONFIG.cityCount + 1);
        cities.forEach((c, i) => {
            c.x = citySpacing * (i + 1);
            c.y = height - 25;
        });

        // サイロの再配置
        if (silos.length === 3) {
            silos[0].x = 40;            // Left
            silos[1].x = width / 2;     // Center
            silos[2].x = width - 40;    // Right
            silos.forEach(s => s.y = height - 35);
        }
    }

    window.addEventListener('resize', resize);

    // Classes
    class Silo {
        constructor(x) {
            this.x = x; this.y = height - 35;
            this.ammo = CONFIG.baseAmmo;
            this.active = true;
        }
        draw() {
            // Base
            ctx.fillStyle = '#aa0';
            ctx.beginPath();
            ctx.moveTo(this.x - 25, height);
            ctx.lineTo(this.x - 10, this.y);
            ctx.lineTo(this.x + 10, this.y);
            ctx.lineTo(this.x + 25, height);
            ctx.fill();
            
            // Ammo
            if (this.active) {
                ctx.fillStyle = '#fff';
                const rows = 4;
                let drawn = 0;
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<=r; c++) {
                        if (drawn < this.ammo) {
                            const px = this.x - (r*6)/2 + c*6;
                            const py = this.y + 8 + r*6;
                            ctx.fillRect(px, py, 4, 4);
                            drawn++;
                        }
                    }
                }
            }
            // Count Text
            ctx.fillStyle = '#f00';
            ctx.font = '12px Courier';
            ctx.textAlign = 'center';
            ctx.fillText(this.ammo > 0 ? this.ammo : "LOW", this.x, this.y - 5);
        }
    }

    class City {
        constructor(x) {
            this.x = x; this.y = height - 25;
            this.active = true;
        }
        draw() {
            if (!this.active) return;
            ctx.fillStyle = '#0ff';
            ctx.fillRect(this.x - 15, this.y + 5, 30, 15);
            ctx.fillRect(this.x - 5, this.y - 5, 10, 10);
        }
    }

    class Missile {
        constructor(sx, sy, tx, ty, speed, color, isEnemy) {
            this.x = sx; this.y = sy;
            this.sx = sx; this.sy = sy; // Start pos
            this.tx = tx; this.ty = ty; // Target pos
            this.active = true;
            this.color = color;
            this.isEnemy = isEnemy;
            this.speed = speed;

            const dx = tx - sx;
            const dy = ty - sy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            this.vx = (dx / dist); // Normalized vector
            this.vy = (dy / dist);
            this.totalDist = dist;
            this.traveled = 0;
        }
        update(dt) {
            const moveStep = this.speed * dt;
            this.x += this.vx * moveStep;
            this.y += this.vy * moveStep;
            this.traveled += moveStep;

            if (this.isEnemy) {
                // 敵: 地面(ty)に到達したら爆発
                if (this.y >= this.ty) this.explode();
                
                // MIRV 分裂 (画面上部40%以内、かつランダム)
                // dtを使うことでフレームレート依存を解消
                if (this.active && this.y < height * 0.4) {
                    // 1秒あたり約0.5%の確率 (splitChance per second)
                    if (Math.random() < 0.3 * dt) this.split();
                }
            } else {
                // プレイヤー: ターゲット距離に到達したら爆発
                if (this.traveled >= this.totalDist) this.explode();
            }
        }
        explode() {
            this.active = false;
            explosions.push(new Explosion(this.x, this.y, this.isEnemy));
            if (!this.isEnemy) AudioSys.playExplosion();
        }
        split() {
            this.active = false;
            // 2つに分裂
            for(let i=0; i<2; i++) {
                // 生きている都市を狙う
                const targets = cities.filter(c => c.active);
                let tx, ty;
                if (targets.length > 0 && Math.random() < 0.8) {
                    const t = targets[Math.floor(Math.random() * targets.length)];
                    tx = t.x + (Math.random()*40-20); // 少しずらす
                    ty = t.y;
                } else {
                    tx = Math.random() * width;
                    ty = height;
                }
                // 速度1.2倍
                missiles.push(new Missile(this.x, this.y, tx, ty, this.speed * 1.2, '#f00', true));
            }
        }
        draw() {
            ctx.beginPath();
            ctx.strokeStyle = this.color;
            ctx.lineWidth = this.isEnemy ? 2 : 1;
            ctx.moveTo(this.sx, this.sy);
            ctx.lineTo(this.x, this.y);
            ctx.stroke();
            
            ctx.fillStyle = '#fff';
            ctx.fillRect(this.x-1, this.y-1, 2, 2);
        }
    }

    class Explosion {
        constructor(x, y, causedByEnemy) {
            this.x = x; this.y = y;
            this.r = 1;
            this.maxR = CONFIG.explosionRadius;
            this.active = true;
            this.growing = true;
            this.causedByEnemy = causedByEnemy;
        }
        update(dt) {
            const growthSpeed = 100 * dt; // 拡大速度
            if (this.growing) {
                this.r += growthSpeed;
                if (this.r >= this.maxR) this.growing = false;
            } else {
                this.r -= growthSpeed * 0.5;
                if (this.r <= 0) this.active = false;
            }
        }
        draw() {
            const flicker = Math.random() > 0.5 ? '#fff' : (this.causedByEnemy ? '#ff0' : '#f0f');
            ctx.fillStyle = flicker;
            ctx.beginPath();
            ctx.arc(this.x, this.y, Math.max(0, this.r), 0, Math.PI*2);
            ctx.fill();
        }
    }

    // --- Main Loop ---

    function initGame() {
        resize(); // 初回配置
        score = 0;
        level = 1;
        scoreEl.innerText = "SCORE: " + score;
        
        cities = [];
        const spacing = width / (CONFIG.cityCount + 1);
        for(let i=1; i<=CONFIG.cityCount; i++) cities.push(new City(spacing * i));
        
        silos = [new Silo(0), new Silo(0), new Silo(0)]; // 座標はrepositionでセット
        repositionObjects();

        startWave();
    }

    function startWave() {
        gameActive = true;
        isPaused = false;
        overlay.style.display = 'none';
        bonusScreen.style.display = 'none';
        
        // サイロ回復
        silos.forEach(s => s.ammo = CONFIG.baseAmmo);
        
        missiles = [];
        explosions = [];
        
        // ウェーブ設定
        CONFIG.missilesToSpawn = 8 + (level * 2);
        CONFIG.spawned = 0;
        CONFIG.currentEnemySpeed = CONFIG.enemySpeedBase + (level * 5);
        
        lastTime = performance.now();
        AudioSys.playStart();
        
        requestAnimationFrame(loop);
    }

    function loop(timestamp) {
        if (!gameActive || isPaused) return;
        
        const dt = (timestamp - lastTime) / 1000; // 秒単位の経過時間
        lastTime = timestamp;

        // フレーム飛び防止
        if (dt > 0.1) {
            requestAnimationFrame(loop);
            return; 
        }

        update(dt);
        draw();
        
        requestAnimationFrame(loop);
    }

    function update(dt) {
        // 敵出現
        spawnTimer += dt;
        // レベルが上がると出現間隔が短くなる
        const spawnRate = Math.max(0.5, 2.0 - (level * 0.15));
        
        if (CONFIG.spawned < CONFIG.missilesToSpawn && spawnTimer > spawnRate) {
            spawnTimer = 0;
            CONFIG.spawned++;
            
            // ターゲット決定
            let tx, ty;
            const targets = [...cities.filter(c=>c.active), ...silos.filter(s=>s.active)];
            if (targets.length > 0 && Math.random() < 0.7) {
                const t = targets[Math.floor(Math.random() * targets.length)];
                tx = t.x; ty = t.y;
            } else {
                tx = Math.random() * width; ty = height;
            }
            
            missiles.push(new Missile(
                Math.random()*width, 0, 
                tx, ty, 
                CONFIG.currentEnemySpeed, 
                '#f00', true
            ));
        }

        // 更新
        missiles.forEach(m => m.update(dt));
        missiles = missiles.filter(m => m.active);

        explosions.forEach(e => e.update(dt));
        explosions = explosions.filter(e => e.active);

        checkCollisions();
        checkWaveEnd();
    }

    function checkCollisions() {
        // 爆風 vs 敵
        explosions.forEach(exp => {
            missiles.forEach(m => {
                if (!m.active || !m.isEnemy) return;
                const distSq = (m.x - exp.x)**2 + (m.y - exp.y)**2;
                if (distSq < (exp.r + 10)**2) {
                    m.active = false;
                    explosions.push(new Explosion(m.x, m.y, false)); // 誘爆
                    score += 25 * level;
                    scoreEl.innerText = "SCORE: " + score;
                    AudioSys.playExplosion();
                }
            });
        });

        // 敵 vs 地上
        missiles.forEach(m => {
            if (!m.active || !m.isEnemy) return;
            // 低空のみ判定
            if (m.y > height - 40) {
                // 都市
                cities.forEach(c => {
                    if (c.active && Math.abs(m.x - c.x) < 25 && Math.abs(m.y - c.y) < 20) {
                        c.active = false;
                        m.active = false; // 直撃したらミサイルも消える（爆発エフェクトはExplosionクラスで）
                        explosions.push(new Explosion(c.x, c.y, true));
                    }
                });
                // サイロ
                silos.forEach(s => {
                    if (s.active && s.ammo > 0 && Math.abs(m.x - s.x) < 25 && Math.abs(m.y - s.y) < 20) {
                        s.ammo = 0; // 弾薬喪失
                        m.active = false;
                        explosions.push(new Explosion(s.x, s.y, true));
                    }
                });
            }
        });
    }

    function checkWaveEnd() {
        const activeCities = cities.filter(c => c.active);
        if (activeCities.length === 0) {
            gameOver();
            return;
        }

        if (CONFIG.spawned >= CONFIG.missilesToSpawn && 
            missiles.filter(m => m.isEnemy).length === 0 && 
            explosions.length === 0) {
            
            // ウェーブクリア
            isPaused = true;
            
            // ボーナス計算
            const ammoLeft = silos.reduce((a, b) => a + b.ammo, 0);
            const cityLeft = activeCities.length;
            const ammoBonus = ammoLeft * 5 * level;
            const cityBonus = cityLeft * 100 * level;
            const total = ammoBonus + cityBonus;
            score += total;
            scoreEl.innerText = "SCORE: " + score;

            document.getElementById('bonus-val').innerText = total;
            document.getElementById('ammo-bonus').innerText = ammoLeft;
            document.getElementById('city-bonus').innerText = cityLeft;
            
            bonusScreen.style.display = 'flex';
            
            setTimeout(() => {
                level++;
                startWave();
            }, 3000);
        }
    }

    function draw() {
        // 背景色（レベルで変化）
        ctx.fillStyle = CONFIG.colors[(level-1) % CONFIG.colors.length];
        ctx.fillRect(0, 0, width, height);
        
        // 地面
        ctx.fillStyle = '#aa0';
        ctx.fillRect(0, height-20, width, 20);

        cities.forEach(c => c.draw());
        silos.forEach(s => s.draw());
        missiles.forEach(m => m.draw());
        explosions.forEach(e => e.draw());
    }

    function gameOver() {
        gameActive = false;
        overlay.style.display = 'flex';
        titleText.innerHTML = "GAME OVER";
        statusText.innerText = "SCORE: " + score;
        startBtn.innerText = "TRY AGAIN";
    }

    // --- Input ---
    function handleInput(tx, ty) {
        if (!gameActive || isPaused) return;

        // 一番近くて弾があるサイロを探す
        let bestSilo = null;
        let minDist = Infinity;
        
        silos.forEach(s => {
            if (s.ammo > 0) {
                const d = Math.abs(s.x - tx); // 横距離優先
                if (d < minDist) {
                    minDist = d;
                    bestSilo = s;
                }
            }
        });

        if (bestSilo) {
            bestSilo.ammo--;
            AudioSys.playShoot();
            // プレイヤーミサイル発射
            missiles.push(new Missile(
                bestSilo.x, bestSilo.y, 
                tx, ty, 
                CONFIG.playerSpeed, 
                '#fff', false
            ));
            
            // マーカー
            createMarker(tx, ty);
        } else {
            AudioSys.playEmpty();
        }
    }

    function createMarker(x, y) {
        const el = document.createElement('div');
        el.style.position = 'absolute';
        el.style.left = (x - 10) + 'px';
        el.style.top = (y - 10) + 'px';
        el.style.width = '20px';
        el.style.height = '20px';
        el.style.border = '1px solid rgba(255,255,255,0.5)';
        el.style.transform = 'rotate(45deg)';
        el.style.pointerEvents = 'none';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 500);
    }

    canvas.addEventListener('mousedown', e => handleInput(e.clientX, e.clientY));
    
    // マルチタッチ対応
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            const t = e.changedTouches[i];
            handleInput(t.clientX, t.clientY);
        }
    }, {passive: false});

    startBtn.addEventListener('click', () => {
        AudioSys.init();
        initGame();
    });

    // 初期化
    resize();

</script>
</body>
</html>
